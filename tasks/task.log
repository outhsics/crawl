[ { id: '5b346e8f5188251e1d39bd09',
    title: '真的，移动端尺寸自适应与dpr无关',
    href: 'https://juejin.im/post/5b346e8f5188251e1d39bd09',
    content: '<h2 class="heading" data-id="heading-0">前言</h2>\n<p>做移动端自适应时可能很多人都对自适应和dpr之间的关系产生疑问,也有一些人会疑虑比如我的自适应方案没有加dpr会不会出问题,针对这些疑问我说一下我的见解,希望能解除你的担忧。</p>\n<h2 class="heading" data-id="heading-1">1. 什么是尺寸自适应</h2>\n<p>首先说到自适应,可能在不同人眼里理解不同，特别与响应式的关系,在这里说一下我所理解的自适应,和其与响应式的区别。先说响应式设计,响应式设计表示在不同的屏幕尺寸下,都有良好的布局和内容表现,简单一点的说,就是一个页面可以适配多种不同尺寸的屏幕,而且看上去还是设计良好的。为了实现这个目的,可能会利用js或者css去动态改变布局的尺寸,在这个过程中会伴随元素尺寸的改变,布局的改变,甚至会把元素隐藏,比如在pc端显示的页面转到移动端就会这样。而自适应往往考虑的是另一个方面,就是希望页面的设计与设计稿的设计比例一致,这个也是做自适应的目的,在这个过程中针对不同的屏幕宽度元素的尺寸也会改变,但是一般不会有布局改变,和元素的隐藏,因为设计稿就这样,我们得按设计师妹子的尺寸来写页面。所以按照我以上的说法,那些按照css媒体查询写的自适应严格来说不叫自适应,因为断点之间会造成比例误差,而让误差少一点就得多插值。很明显使用css媒体查询并不是做自适应的好方法,我们需要一种准确的方法来做这个事,这个时候js就出来了,下面将会列举坊间流传甚广的淘宝方案和网易方案。</p>\n<h2 class="heading" data-id="heading-2">2. 淘宝方案</h2>\n<p>点这里可以看到淘宝方案具体的代码<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhuainanhai%2Fflexible%2Fblob%2Fmaster%2Fpublic%2Fjs%2Fframe%2Fflexible.debug.js" rel="nofollow noopener noreferrer">flexible</a></p>\n<p>当然具体的代码是做了很多的边界处理和兼容处理的,但是核心可以浓缩为以下代码</p>\n<pre><code class="hljs bash copyable" lang="bash">(<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n    var dpr = window.devicePixelRatio;\n    var meta = document.createElement(<span class="hljs-string">&apos;meta&apos;</span>);\n    var scale = 1 / dpr;\n    meta.setAttribute(<span class="hljs-string">&apos;name&apos;</span>, <span class="hljs-string">&apos;viewport&apos;</span>);\n    meta.setAttribute(<span class="hljs-string">&apos;content&apos;</span>, <span class="hljs-string">&apos;width=device-width, user-scalable=no, initial-scale=&apos;</span> + scale +\n      <span class="hljs-string">&apos;, maximum-scale=&apos;</span> + scale + <span class="hljs-string">&apos;, minimum-scale=&apos;</span> + scale);\n    document.getElementsByTagName(<span class="hljs-string">&apos;head&apos;</span>)[0].appendChild(meta);\n    // 动态设置的缩放大小会影响布局视口的尺寸\n      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">resize</span></span>() {\n      var deviceWidth  = document.documentElement.clientWidth;\n      document.documentElement.style.fontSize = (deviceWidth / 10) +<span class="hljs-string">&apos;px&apos;</span>;\n         }\n    resize();\n    window.onresize = resize;\n  })()\n<span class="copy-code-btn">复制代码</span></code></pre><p>这段代码放在浏览器上就能做到自适应了,他的过程是先获取设备的dpr,所谓的dpr就是设备像素比,什么是设备像素比呢,就是单位尺寸内,设备物理像素的个数除以设备独立像素的大小,物理像素就是手机屏幕上一个一个的发光的点,大小是固定的,独立像素也叫做逻辑像素,css设置的像素大小就是逻辑像素,对于dpr等于2的手机屏幕,设置css宽度为1px,其实覆盖的是2个设备物理像素。回到正题,拿到dpr后,通过动态设置meta的viewport值,进行对布局的缩放操作。这里有一个关键,就是设置 width=device-width和initial-scale的大小,在描述两者的作用之前我们先要理解一个概念就是布局视口,布局视口在之前有一个别名叫做初始包含块,而在比较早的文献中初始包含块也叫做画布。理解画布可能比理解布局视口更简单,如果你按比例绘图,很多时候就要参照你所用画布的大小,比如设计师在750px画了一个200px的正方形,如果你要在一张大小是100cm的纸上画,你可能就要这样计算正方形的宽度了 100cm * 200 / 750,可以看到这个计算中是没有用到dpr,你的笔触跨过多少个纸张分子,多少个原子根本就不影响我的绘图比例。我们的画画的过程就相当于设置css的过程,css的尺寸依赖的就是布局视口的大小,而网页的布局视口大小在标准模式下可以这样获取</p>\n<p>document.documentElement.clientWidth,</p>\n<p>而两个关键的元素设置 width=device-width,initial-scale = scale,做的事情就是先把布局视口放大dpr倍,然后整体缩放相应倍数以适应设备尺寸。这个也很容易验证在控制台打印布局视口大小就行了</p>\n<p></p><figure><img alt="图片" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/6/28/16444eb6cffc5c8b?imageView2/0/w/1280/h/960/ignore-error/1" data-width="800" data-height="439"><figcaption></figcaption></figure>\n这是按照640px设计规范,设计图上标注200px元素大小,可以看出布局视口放大了3倍,然后再整体缩放到设备屏幕大小,由于这里是证明这个过程其实与dpr无关,我现在把scale的大小分别设置为\n0.1 和 0.5<p></p>\n<pre><code class="hljs bash copyable" lang="bash">var meta = document.createElement(<span class="hljs-string">&apos;meta&apos;</span>);\n        var scale = 0.1;\n        meta.setAttribute(<span class="hljs-string">&apos;name&apos;</span>, <span class="hljs-string">&apos;viewport&apos;</span>);\n<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="0.1" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/6/28/16444ed132e70696?imageView2/0/w/1280/h/960/ignore-error/1" data-width="800" data-height="432"><figcaption></figcaption></figure><p></p>\n<pre><code class="hljs bash copyable" lang="bash">var meta = document.createElement(<span class="hljs-string">&apos;meta&apos;</span>);\n        var scale = 0.5;\n        meta.setAttribute(<span class="hljs-string">&apos;name&apos;</span>, <span class="hljs-string">&apos;viewport&apos;</span>);\n<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="0.5" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/6/28/16444edd6d16eb1c?imageView2/0/w/1280/h/960/ignore-error/1" data-width="800" data-height="443"><figcaption></figcaption></figure><p></p>\n<p>这里可以看到就算我设置scale不等于 1 / drp 的大小也不妨碍我按设计图的比例画出元素\n这里要注意两点,因为我是用chrome模拟的,设置的时候发现几个问题</p>\n<ol>\n<li>scale的值如果小于0.1布局视口也只能放大10倍,也就是布局视口最多放大10倍</li>\n<li>当scale的值大于1时布局视口并不会缩小,而且布局视口不再匹配设备宽度,这种情况实际不会出现。</li>\n<li>如果你引入了flexible.js进行测试,要注意删除边界条件,因为缩放影响了布局视口大小,相应的边界条件会触发,导致误认为dpr与自适应有关</li>\n</ol>\n<p>要做到自适应关键是让元素的尺寸与布局视口绑定关系,在这里虽然布局视口放大了,但并不影响这种绑定关系,这里淘宝方案把布局视口的宽度分割了十等份,每份的大小相当于布局宽度的十分之一,而把每份的大小分配给根元素的字体大小,元素尺寸就可以设置rem单位来与布局视口绑定关系,以200px尺寸为例,他们比例映射是这样的</p>\n<p>200px : 640px =&gt; xrem : 10rem</p>\n<p>这里的10rem就是布局视口宽度,元素尺寸只要维持这个比例关系就行了,与dpr是没有关系的</p>\n<p>x= 10 * 200 / 640 = 3.125rem</p>\n<p>这里的计算可能会费一点时间,也有一些插件可以辅助把px转为rem的\n但是方案是死的,人是活的,你只要把淘宝固有的十等分改一下就行了,比如设计稿是640px的\n改一下</p>\n<pre><code class="hljs bash copyable" lang="bash">document.documentElement.style.fontSize = (deviceWidth / 6.4) +<span class="hljs-string">&apos;px&apos;</span>;\n<span class="copy-code-btn">复制代码</span></code></pre><p>分了6.4等份</p>\n<p>200px : 640px =&gt; xrem : 6.4rem</p>\n<p>x一看就知道是 2rem</p>\n<p>流程：  rem =&gt; 根元素字体大小 =&gt; 布局视口</p>\n<p>当然也可以分割为100等份,这样方便为以后使用vw单位进行过渡</p>\n<p>那么为什么淘宝要引入dpr,把布局放大再缩小呢,其中一点就是这个方案可以很好地解决1px边框的问题,对于高清屏来说设置1px像素大小,其实横跨的是dpr个设备像素,这样看起来线条不够细,与设计稿就产生出入,而通过布局放大再缩小的方案刚好就弥补了这个问题。但是随之而来也带来一个问题,看上面的截图我们看到字体大小发生了改变,在scale设置为0.1时基本就看不见了,原因是一般我们的字体大小的设置不会使用rem,而是使用px单位,这里的字体大小没有随布局视口的放大而增大,却随页面的整体缩放而缩小了,这里就得要针对不同的dpr做响应的处理,在淘宝的代码中我们可以看到</p>\n<pre><code class="hljs bash copyable" lang="bash">docEl.setAttribute(<span class="hljs-string">&apos;data-dpr&apos;</span>, dpr);\n<span class="copy-code-btn">复制代码</span></code></pre><p>就是通过在根元素上挂载dpr信息,然后设置相应的css属性例如</p>\n<pre><code class="hljs bash copyable" lang="bash">[data-dpr=2] div{\n    font-size: 32px\n}\n[data-dpr=3] div{\n    font-size: 48px\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>特别对于安卓手机,各种神奇的dpr,如果每个都这样设置将会是灾难\n所以淘宝非常聪明</p>\n<pre><code class="hljs bash copyable" lang="bash"> var isAndroid = win.navigator.appVersion.match(/android/gi);\n        var isIPhone = win.navigator.appVersion.match(/iphone/gi);\n        var devicePixelRatio = win.devicePixelRatio;\n        <span class="hljs-keyword">if</span> (isIPhone) {\n            // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案\n            <span class="hljs-keyword">if</span> (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) {                \n                dpr = 3;\n            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)){\n                dpr = 2;\n            } <span class="hljs-keyword">else</span> {\n                dpr = 1;\n            }\n        } <span class="hljs-keyword">else</span> {\n            // 其他设备下，仍旧使用1倍的方案\n            dpr = 1;\n        }\n        scale = 1 / dpr;\n<span class="copy-code-btn">复制代码</span></code></pre><p>够简单直接,安卓高清屏是不存在的, 但是其实影响也不大,就是安卓屏的1px线条粗一点而已</p>\n<p>如果除了要做自适应还要做响应式,那也得像上面设置字体一样一个一个设置,因为css媒体查询也是针对布局视口尺寸的。对于淘宝他们来说,肯定有一套工程化的方案来解决这种技术难题,对于遇到这个坑的伙伴估计得自已想办法了,预处理器是必不可少的。\n从前面可以知道淘宝引入dpr并不是为了做自适应的,而是为了解决1px问题的,当然也引入了其他难题,既然如此,放弃解决1px问题,不就简单得多,网易方案就是这么做的。</p>\n<h2 class="heading" data-id="heading-3">3.网易方案</h2>\n<p>去除了边界处理和兼容处理，由于没有动态设置meta所以要在head中引入</p>\n<pre><code class="hljs bash copyable" lang="bash"> &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;\n<span class="copy-code-btn">复制代码</span></code></pre><pre><code class="hljs bash copyable" lang="bash"> (<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n    var dpr = window.devicePixelRatio;\n    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">resize</span></span>() {\n      var deviceWidth = document.documentElement.clientWidth;\n    document.documentElement.style.fontSize = (deviceWidth / 6.4) +<span class="hljs-string">&apos;px&apos;</span>;\n   }\n    resize();\n    window.onresize = resize;\n  })()\n<span class="copy-code-btn">复制代码</span></code></pre><p>网易方案没有引入dpr相关的,这也说明了移动端自适应与dpr是无关的</p>\n<p></p><figure><img alt="0.6" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/6/28/16444f837fa7be33?imageView2/0/w/1280/h/960/ignore-error/1" data-width="800" data-height="439"><figcaption></figcaption></figure>\n从图片中可以看出和淘宝方案的区别,布局视口没有放大,整个页面也没有缩放,但是并不影响与设计图的比例<p></p>\n<p>200px : 640px =&gt; xrem : 6.4rem</p>\n<p>x= 2rem</p>\n<p>流程:  rem =&gt; 根元素的大小 =&gt; 布局视口</p>\n<p>既然自适应与dpr无关那么就可以扩展出很多方案了</p>\n<h2 class="heading" data-id="heading-4">4. 其他方案</h2>\n<p>1.在布局视口等于设备宽度时,直接把根元素字体大小绑定到设备宽度大小上</p>\n<pre><code class="hljs bash copyable" lang="bash">document.documentElement.style.fontSize = (screen.width/ 6.4) +<span class="hljs-string">&apos;px&apos;</span>;\n<span class="copy-code-btn">复制代码</span></code></pre><p>这里有关相关的文章 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F06%2Fpseudo-response-layout-base-on-screen-width%2F" rel="nofollow noopener noreferrer">基于screen.width的伪响应式开发</a></p>\n<p>2.直接定死布局视口</p>\n<pre><code class="hljs bash copyable" lang="bash">&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;\n&lt;head&gt;\n  &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;\n  &lt;meta http-equiv=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> content=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;\n  &lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=640, user-scalable=no&quot;</span>&gt;//定死为设计稿的尺寸\n  &lt;meta name=<span class="hljs-string">&quot;renderer&quot;</span> content=<span class="hljs-string">&quot;webkit&quot;</span>&gt;\n  &lt;title&gt;定死布局视口&lt;/title&gt;\n  &lt;style&gt;\n    html, body {\n      margin: 0\n    }\n    div {\n      width: 200px;\n      height: 200px;\n      background: red;\n    }\n\n    body {\n      background: blue;\n    }\n  &lt;/style&gt;\n  &lt;script&gt;\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=<span class="hljs-string">&quot;size200px&quot;</span>&gt;元素大小200px&lt;/div&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img alt="0.001" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/6/28/16444fac35b57970?imageView2/0/w/1280/h/960/ignore-error/1" data-width="800" data-height="383"><figcaption></figcaption></figure><p></p>\n<p>不用rem单位,不用设置js,但是布局视口定死后,就不能用css媒体查询做响应式了,从这里也可以看出viewport属性的作用,就是让布局视口通过缩放来适配屏幕宽度,width=device.width仅仅是让布局视口初始大小等于设备宽度,后面设置的initial-scale是用来缩放布局视口大小,而且默认是布局视口初始大小等于设备宽度,也就是所谓的理想视口,换个说法就是如果你设置了initial-scale你可以不用设置 width=device.width了,淘宝方案你把width=device.width去掉,并不会影响自适应过程,加上主要是防止一些不按规范的浏览器出现兼容问题。如果还不能理解viewport的作用,那么可以参考svg中的viewport和viewBox的关系，原理是一样的。</p>\n<p>3.使用新出单位 vw, vw 就是专门为自适应而出现的,100vw就是布局视口的宽度,非常厉害,你也不用设置js了</p>\n<p>200px: 640px =&gt; xvw : 100vw</p>\n<p>x=200 * 100 / 640 = 31.25vw</p>\n<p>流程: vw =&gt; 布局视口</p>\n<p>看一下兼容性</p>\n<p></p><figure><img class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/6/28/16444fc469953bd0?imageView2/0/w/1280/h/960/ignore-error/1" data-width="800" data-height="216"><figcaption></figcaption></figure><p></p>\n<p>兼容还可以,这里也有相关的资料<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.w3cplus.com%2Fcss%2Ftaobao-2018-year.html" rel="nofollow noopener noreferrer"> 分享手淘过年项目中采用到的前端技术</a></p>\n<h2 class="heading" data-id="heading-5">总结</h2>\n<p>移动端尺寸自适应与dpr无关,除了淘宝方案外,其他方案都得处理1px的问题,但也减少针对不同dpr设备做响应式处理的麻烦,而且其中也没有一种一劳永逸的方案能解决全部问题。而作为新出来的单位vw,是时候该入坑了</p>\n<h2 class="heading" data-id="heading-6">参考文章</h2>\n<pre><code class="copyable">1. 张鑫旭 [基于screen.width的伪响应式开发](https://www.zhangxinxu.com/wordpress/2016/06/pseudo-response-layout-base-on-screen-width/)\n\n2. 大漠 [分享手淘过年项目中采用到的前端技术](https://www.w3cplus.com/css/taobao-2018-year.html)\n\n3. [fleible](https://github.com/huainanhai/flexible/blob/master/public/js/frame/flexible.debug.js)\n\n4. 张鑫旭 [设备像素比devicePixelRatio简单介绍](设备像素比devicePixelRatio简单介绍)<span class="copy-code-btn">复制代码</span></code></pre>\n',
    tags: [ '前端', '响应式设计' ] },
  { id: '5b3f3647f265da0f926b64db',
    title: '浅谈前端响应式设计（一）',
    href: 'https://juejin.im/post/5b3f3647f265da0f926b64db',
    content: '<p>现实世界有很多是以响应式的方式运作的，例如我们会在收到他人的提问，然后做出响应，给出相应的回答。在开发过程中我也应用了大量的响应式设计，积累了一些经验，希望能抛砖引玉。</p>\n<p>响应式编程（Reactive Programming）和普通的编程思路的主要区别在于，响应式以推（<code>push</code>）的方式运作，而非响应式的编程思路以拉（<code>pull</code>）的方式运作。例如，事件就是一个很常见的响应式编程，我们通常会这么做：</p>\n<pre><code class="hljs js copyable" lang="js">button.on(<span class="hljs-string">&apos;click&apos;</span>, () =&gt; {\n    <span class="hljs-comment">// ...</span>\n})\n<span class="copy-code-btn">复制代码</span></code></pre><p>而非响应式方式下，就会变成这样：</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {\n    <span class="hljs-keyword">if</span> (button.clicked) {\n        <span class="hljs-comment">// ...</span>\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>显然，无论在是代码的优雅度还是执行效率上，非响应式的方式都不如响应式的设计。</p>\n<h2 class="heading" data-id="heading-0">Event Emitter</h2>\n<p><code>Event Emitter</code>是大多数人都很熟悉的事件实现，它很简单也很实用，我们可以利用<code>Event Emitter</code>实现简单的响应式设计，例如下面这个异步搜索：</p>\n<pre><code class="hljs jsx copyable" lang="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    state = {\n        <span class="hljs-attr">value</span>: <span class="hljs-string">&apos;&apos;</span>\n    }\n\n    onChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.props.events.emit(<span class="hljs-string">&apos;onChange&apos;</span>, e.target.value)\n    }\n\n    afterChange = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.setState({\n            value\n        })\n    }\n\n    componentDidMount() {\n        <span class="hljs-keyword">this</span>.props.events.on(<span class="hljs-string">&apos;onChange&apos;</span>, <span class="hljs-keyword">this</span>.afterChange)\n    }\n\n    componentWillUnmount() {\n        <span class="hljs-keyword">this</span>.props.events.off(<span class="hljs-string">&apos;onChange&apos;</span>, <span class="hljs-keyword">this</span>.afterChange)\n    }\n\n    render() {\n        <span class="hljs-keyword">const</span> { value } = <span class="hljs-keyword">this</span>.state\n\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{value}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.onChange}</span> /&gt;</span>\n        )\n    }\n}\n\nclass Search extends Component {\n    doSearch = (value) =&gt; {\n        ajax(/* ... */).then(list =&gt; this.setState({\n            list\n        }))\n    }\n\n    componentDidMount() {\n        this.props.events.on(&apos;onChange&apos;, this.doSearch)\n    }\n\n    componentWillUnmount() {\n        this.props.events.off(&apos;onChange&apos;, this.doSearch)\n    }\n\n    render() {\n        const { list } = this.state\n\n        return (\n            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n                {list.map(item =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.value}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)}\n            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n        )\n    }\n}\n</span><span class="copy-code-btn">复制代码</span></code></pre><p>这里我们会发现用<code>Event Emitter</code>的实现有很多缺点，需要我们手动在<code>componentWillUnmount</code>里进行资源的释放。它的表达能力不足，例如我们在搜索的时候需要聚合多个数据源的时候：</p>\n<pre><code class="hljs jsx copyable" lang="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Search</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    foo = <span class="hljs-string">&apos;&apos;</span>\n    bar = <span class="hljs-string">&apos;&apos;</span>\n\n    doSearch = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        ajax({\n            foo,\n            bar\n        }).then(<span class="hljs-function"><span class="hljs-params">list</span> =&gt;</span> <span class="hljs-keyword">this</span>.setState({\n            list\n        }))\n    }\n\n    fooChange = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.foo = value\n        <span class="hljs-keyword">this</span>.doSearch()\n    }\n\n    barChange = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {\n        <span class="hljs-keyword">this</span>.bar = value\n        <span class="hljs-keyword">this</span>.doSearch()\n    }\n\n    componentDidMount() {\n        <span class="hljs-keyword">this</span>.props.events.on(<span class="hljs-string">&apos;fooChange&apos;</span>, <span class="hljs-keyword">this</span>.fooChange)\n        <span class="hljs-keyword">this</span>.props.events.on(<span class="hljs-string">&apos;barChange&apos;</span>, <span class="hljs-keyword">this</span>.barChange)\n    }\n\n    componentWillUnmount() {\n        <span class="hljs-keyword">this</span>.props.events.off(<span class="hljs-string">&apos;fooChange&apos;</span>, <span class="hljs-keyword">this</span>.fooChange)\n        <span class="hljs-keyword">this</span>.props.events.off(<span class="hljs-string">&apos;barChange&apos;</span>, <span class="hljs-keyword">this</span>.barChange)\n    }\n\n    render() {\n        <span class="hljs-comment">// ...</span>\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>显然开发效率很低。</p>\n<h2 class="heading" data-id="heading-1">Redux</h2>\n<p><code>Redux</code>采用了一个事件流的方式实现响应式，在<code>Redux</code>中由于<code>reducer</code>必须是纯函数，因此要实现响应式的方式只有订阅中或者是在中间件中。</p>\n<p>如果通过订阅<code>store</code>的方式，由于<code>Redux</code>不能准确拿到哪一个数据放生了变化，因此只能通过脏检查的方式。例如：</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWatcher</span>(<span class="hljs-params">mapState, callback</span>) </span>{\n    <span class="hljs-keyword">let</span> previousValue = <span class="hljs-literal">null</span>\n    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> {\n        store.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n            <span class="hljs-keyword">const</span> value = mapState(store.getState())\n            <span class="hljs-keyword">if</span> (value !== previousValue) {\n                callback(value)\n            }\n            previousValue = value\n        })\n    }\n}\n\n<span class="hljs-keyword">const</span> watcher = createWatcher(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {\n    <span class="hljs-comment">// ...</span>\n}, () =&gt; {\n    <span class="hljs-comment">// ...</span>\n})\n\nwatcher(store)\n<span class="copy-code-btn">复制代码</span></code></pre><p>这个方法有两个缺点，一是在数据很复杂且数据量比较大的时候会有效率上的问题；二是，如果<code>mapState</code>函数依赖上下文的话，就很难办了。在<code>react-redux</code>中，<code>connect</code>函数中<code>mapStateToProps</code>的第二个参数是<code>props</code>，可以通过上层组件传入<code>props</code>来获得需要的上下文，但是这样监听者就变成了<code>React</code>的组件，会随着组件的挂载和卸载被创建和销毁，如果我们希望这个响应式和组件无关的话就有问题了。</p>\n<p>另一种方式就是在中间件中监听数据变化。得益于<code>Redux</code>的设计，我们通过监听特定的事件（Action）就可以得到对应的数据变化。</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-keyword">const</span> search = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (dispatch, getState) =&gt; {\n    <span class="hljs-comment">// ...</span>\n}\n\n<span class="hljs-keyword">const</span> middleware = <span class="hljs-function">(<span class="hljs-params">{ dispatch }</span>) =&gt;</span> next =&gt; <span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> {\n    <span class="hljs-keyword">switch</span> action.type {\n        <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;FOO_CHANGE&apos;</span>:\n        <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;BAR_CHANGE&apos;</span>: {\n            <span class="hljs-keyword">const</span> nextState = next(action)\n            <span class="hljs-comment">// 在本次dispatch完成以后再去进行新的dispatch</span>\n            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(search()), <span class="hljs-number">0</span>)\n            <span class="hljs-keyword">return</span> nextState\n        }\n        <span class="hljs-keyword">default</span>:\n            <span class="hljs-keyword">return</span> next(action)\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>这个方法能解决大多数的问题，但是在<code>Redux</code>中，中间件和<code>reducer</code>实际上隐式订阅了所有的事件（Action），这显然是有些不合理的，虽然在没有性能问题的前提下是完全可以接受的。</p>\n<h2 class="heading" data-id="heading-2">面向对象的响应式</h2>\n<p><code>ECMASCRIPT 5.1</code>引入了<code>getter</code>和<code>setter</code>，我们可以通过<code>getter</code>和<code>setter</code>实现一种响应式。</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>{\n    _foo = <span class="hljs-string">&apos;&apos;</span>\n\n    get foo() {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._foo\n    }\n\n    set foo(value) {\n        <span class="hljs-keyword">this</span>._foo = value\n        <span class="hljs-keyword">this</span>.search()\n    }\n\n    search() {\n        <span class="hljs-comment">// ...</span>\n    }\n}\n\n<span class="hljs-comment">// 当然如果没有getter和setter的话也可以通过这种方式实现</span>\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>{\n    foo = <span class="hljs-string">&apos;&apos;</span>\n\n    getFoo() {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo\n    }\n\n    setFoo(value) {\n        <span class="hljs-keyword">this</span>.foo = value\n        <span class="hljs-keyword">this</span>.search()\n    }\n\n    search() {\n        <span class="hljs-comment">// ...</span>\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p><code>Mobx</code>和<code>Vue</code>就使用了这样的方式实现响应式。当然，如果不考虑兼容性的话我们还可以使用<code>Proxy</code>。</p>\n<p>当我们需要响应若干个值然后得到一个新值的话，在<code>Mobx</code>中我们可以这么做：</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>{\n    @observable hour = <span class="hljs-string">&apos;00&apos;</span>\n    @observable minute = <span class="hljs-string">&apos;00&apos;</span>\n    \n    @computed get time() {\n        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.hour}</span>:<span class="hljs-subst">${<span class="hljs-keyword">this</span>.minute}</span>`</span>\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p><code>Mobx</code>会在运行时收集<code>time</code>依赖了哪些值，并在这些值发生改变（触发<code>setter</code>）的时候重新计算<code>time</code>的值，显然要比<code>EventEmitter</code>的做法方便高效得多，相对<code>Redux</code>的<code>middleware</code>更直观。</p>\n<p>但是这里也有一个缺点，基于<code>getter</code>的<code>computed</code>属性只能描述<code>y = f(x)</code>的情形，但是现实中很多情况<code>f</code>是一个异步函数，那么就会变成<code>y = await f(x)</code>，对于这种情形<code>getter</code>就无法描述了。</p>\n<p>对于这种情形，我们可以通过<code>Mobx</code>提供的<code>autorun</code>来实现：</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>{\n    @observable keyword = <span class="hljs-string">&apos;&apos;</span>\n    @observable searchResult = []\n\n    <span class="hljs-keyword">constructor</span>() {\n        autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n            <span class="hljs-comment">// ajax ...</span>\n        })\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>由于运行时的依赖收集过程完全是隐式的，这里经常会遇到一个问题就是收集到意外的依赖：</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>{\n    @observable loading = <span class="hljs-literal">false</span>\n    @observable keyword = <span class="hljs-string">&apos;&apos;</span>\n    @observable searchResult = []\n\n    <span class="hljs-keyword">constructor</span>() {\n        autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.loading) {\n                <span class="hljs-keyword">return</span>\n            }\n            <span class="hljs-comment">// ajax ...</span>\n        })\n    }\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>显然这里<code>loading</code>不应该被搜索的<code>autorun</code>收集到，为了处理这个问题就会多出一些额外的代码，而多余的代码容易带来犯错的机会。\n或者，我们也可以手动指定需要的字段，但是这种方式就不得不多出一些额外的操作：</p>\n<pre><code class="hljs js copyable" lang="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>{\n    @observable loading = <span class="hljs-literal">false</span>\n    @observable keyword = <span class="hljs-string">&apos;&apos;</span>\n    @observable searchResult = []\n\n    disposers = []\n\n    fetch = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        <span class="hljs-comment">// ...</span>\n    }\n\n    dispose() {\n        <span class="hljs-keyword">this</span>.disposers.forEach(<span class="hljs-function"><span class="hljs-params">disposer</span> =&gt;</span> disposer())\n    }\n\n    <span class="hljs-keyword">constructor</span>() {\n        <span class="hljs-keyword">this</span>.disposers.push(\n            observe(<span class="hljs-keyword">this</span>, <span class="hljs-string">&apos;loading&apos;</span>, <span class="hljs-keyword">this</span>.fetch),\n            observe(<span class="hljs-keyword">this</span>, <span class="hljs-string">&apos;keyword&apos;</span>, <span class="hljs-keyword">this</span>.fetch)\n        )\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{\n    <span class="hljs-keyword">this</span>.mode = <span class="hljs-keyword">new</span> Model()\n\n    componentWillUnmount() {\n        <span class="hljs-keyword">this</span>.state.model.dispose()\n    }\n\n    <span class="hljs-comment">// ...</span>\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>而当我们需要对时间轴做一些描述时，<code>Mobx</code>就有些力不从心了，例如需要延迟5秒再进行搜索。</p>\n<p>在<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Ftech.youzan.com%2Freactive2" rel="nofollow noopener noreferrer">下一篇</a>博客中，将介绍<code>Observable</code>处理异步事件的实践。</p>\n<p></p><figure><img class="lazyload" data-src="https://user-gold-cdn.xitu.io/2018/7/6/1646eeca61466e83?imageView2/0/w/1280/h/960/ignore-error/1" data-width="640" data-height="400"><figcaption></figcaption></figure><p></p>\n',
    tags: [ 'React.js', '前端', '响应式设计', '响应式编程' ] } ]
